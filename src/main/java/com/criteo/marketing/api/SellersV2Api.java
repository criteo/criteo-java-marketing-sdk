/*
 * Marketing API v.1.0
 * IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.
 *
 * OpenAPI spec version: v.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.criteo.marketing.api;

import com.criteo.marketing.ApiCallback;
import com.criteo.marketing.ApiClient;
import com.criteo.marketing.ApiException;
import com.criteo.marketing.ApiResponse;
import com.criteo.marketing.Configuration;
import com.criteo.marketing.Pair;
import com.criteo.marketing.ProgressRequestBody;
import com.criteo.marketing.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.criteo.marketing.model.CreateSellerBudgetMapiMessage;
import com.criteo.marketing.model.ErrorSource;
import java.time.OffsetDateTime;
import com.criteo.marketing.model.SellerBase;
import com.criteo.marketing.model.SellerBudgetMessage;
import com.criteo.marketing.model.SellerCampaignMessage;
import com.criteo.marketing.model.SellerCampaignUpdate;
import com.criteo.marketing.model.UpdateSellerBudgetMessage;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SellersV2Api {
    private ApiClient apiClient;

    public SellersV2Api() {
        this(Configuration.getDefaultApiClient());
    }

    public SellersV2Api(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createSellerBudgets
     * @param authorization JWT Bearer Token (required)
     * @param createSellerBudgets  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call createSellerBudgetsCall(String authorization, List<CreateSellerBudgetMapiMessage> createSellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = createSellerBudgets;

        // create path and map variables
        String localVarPath = "/v2/crp/budgets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSellerBudgetsValidateBeforeCall(String authorization, List<CreateSellerBudgetMapiMessage> createSellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling createSellerBudgets(Async)");
        }
        
        // verify the required parameter 'createSellerBudgets' is set
        if (createSellerBudgets == null) {
            throw new ApiException("Missing the required parameter 'createSellerBudgets' when calling createSellerBudgets(Async)");
        }
        

        okhttp3.Call call = createSellerBudgetsCall(authorization, createSellerBudgets, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Create a collection of budgets.
     * Create one or more new budgets to enable spending with the given limitations.  All three types of budgets can be created this way.                The following constraints apply when creating a new budget.                • &lt;b&gt;sellerId&lt;/b&gt;: the seller MUST be supplied&lt;br /&gt;  • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty array of campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;budgetType&lt;/b&gt;: a budget type MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MUST be supplied&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.
     * @param authorization JWT Bearer Token (required)
     * @param createSellerBudgets  (required)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> createSellerBudgets(String authorization, List<CreateSellerBudgetMapiMessage> createSellerBudgets) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = createSellerBudgetsWithHttpInfo(authorization, createSellerBudgets);
        return resp.getData();
    }

    /**
     * Create a collection of budgets.
     * Create one or more new budgets to enable spending with the given limitations.  All three types of budgets can be created this way.                The following constraints apply when creating a new budget.                • &lt;b&gt;sellerId&lt;/b&gt;: the seller MUST be supplied&lt;br /&gt;  • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty array of campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;budgetType&lt;/b&gt;: a budget type MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MUST be supplied&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.
     * @param authorization JWT Bearer Token (required)
     * @param createSellerBudgets  (required)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> createSellerBudgetsWithHttpInfo(String authorization, List<CreateSellerBudgetMapiMessage> createSellerBudgets) throws ApiException {
        okhttp3.Call call = createSellerBudgetsValidateBeforeCall(authorization, createSellerBudgets, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a collection of budgets. (asynchronously)
     * Create one or more new budgets to enable spending with the given limitations.  All three types of budgets can be created this way.                The following constraints apply when creating a new budget.                • &lt;b&gt;sellerId&lt;/b&gt;: the seller MUST be supplied&lt;br /&gt;  • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty array of campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;budgetType&lt;/b&gt;: a budget type MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MUST be supplied&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.
     * @param authorization JWT Bearer Token (required)
     * @param createSellerBudgets  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call createSellerBudgetsAsync(String authorization, List<CreateSellerBudgetMapiMessage> createSellerBudgets, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = createSellerBudgetsValidateBeforeCall(authorization, createSellerBudgets, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBudgetsBySeller
     * @param sellerId Return only budgets belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getBudgetsBySellerCall(String sellerId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/sellers/{sellerId}/budgets"
            .replaceAll("\\{" + "sellerId" + "\\}", apiClient.escapeString(sellerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (status != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("status", status));
        }

        if (withBalance != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withBalance", withBalance));
        }

        if (withSpend != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withSpend", withSpend));
        }

        if (endAfterDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("endAfterDate", endAfterDate));
        }

        if (startBeforeDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("startBeforeDate", startBeforeDate));
        }

        if (campaignId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignId", campaignId));
        }

        if (type != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBudgetsBySellerValidateBeforeCall(String sellerId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerId' is set
        if (sellerId == null) {
            throw new ApiException("Missing the required parameter 'sellerId' when calling getBudgetsBySeller(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getBudgetsBySeller(Async)");
        }
        

        okhttp3.Call call = getBudgetsBySellerCall(sellerId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, type, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of budgets for this seller.
     * Return a collection of budgets for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used. See the budgets endpoint for additional details.
     * @param sellerId Return only budgets belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> getBudgetsBySeller(String sellerId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String type) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = getBudgetsBySellerWithHttpInfo(sellerId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, type);
        return resp.getData();
    }

    /**
     * Get a collection of budgets for this seller.
     * Return a collection of budgets for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used. See the budgets endpoint for additional details.
     * @param sellerId Return only budgets belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> getBudgetsBySellerWithHttpInfo(String sellerId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String type) throws ApiException {
        okhttp3.Call call = getBudgetsBySellerValidateBeforeCall(sellerId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, type, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of budgets for this seller. (asynchronously)
     * Return a collection of budgets for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used. See the budgets endpoint for additional details.
     * @param sellerId Return only budgets belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getBudgetsBySellerAsync(String sellerId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String type, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getBudgetsBySellerValidateBeforeCall(sellerId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, type, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBudgetsBySellerCampaignId
     * @param sellerCampaignId Return only budgets belonging to the given seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with a positive balance. (optional)
     * @param withSpend Return budgets with a positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getBudgetsBySellerCampaignIdCall(String sellerCampaignId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/seller-campaigns/{sellerCampaignId}/budgets"
            .replaceAll("\\{" + "sellerCampaignId" + "\\}", apiClient.escapeString(sellerCampaignId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (status != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("status", status));
        }

        if (withBalance != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withBalance", withBalance));
        }

        if (withSpend != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withSpend", withSpend));
        }

        if (endAfterDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("endAfterDate", endAfterDate));
        }

        if (startBeforeDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("startBeforeDate", startBeforeDate));
        }

        if (type != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBudgetsBySellerCampaignIdValidateBeforeCall(String sellerCampaignId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerCampaignId' is set
        if (sellerCampaignId == null) {
            throw new ApiException("Missing the required parameter 'sellerCampaignId' when calling getBudgetsBySellerCampaignId(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getBudgetsBySellerCampaignId(Async)");
        }
        

        okhttp3.Call call = getBudgetsBySellerCampaignIdCall(sellerCampaignId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, type, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of budgets for this seller campaign.
     * Return a collection of budgets for this seller campaign filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    See the budgets endpoint for additional details.
     * @param sellerCampaignId Return only budgets belonging to the given seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with a positive balance. (optional)
     * @param withSpend Return budgets with a positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> getBudgetsBySellerCampaignId(String sellerCampaignId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, String type) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = getBudgetsBySellerCampaignIdWithHttpInfo(sellerCampaignId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, type);
        return resp.getData();
    }

    /**
     * Get a collection of budgets for this seller campaign.
     * Return a collection of budgets for this seller campaign filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    See the budgets endpoint for additional details.
     * @param sellerCampaignId Return only budgets belonging to the given seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with a positive balance. (optional)
     * @param withSpend Return budgets with a positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> getBudgetsBySellerCampaignIdWithHttpInfo(String sellerCampaignId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, String type) throws ApiException {
        okhttp3.Call call = getBudgetsBySellerCampaignIdValidateBeforeCall(sellerCampaignId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, type, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of budgets for this seller campaign. (asynchronously)
     * Return a collection of budgets for this seller campaign filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    See the budgets endpoint for additional details.
     * @param sellerCampaignId Return only budgets belonging to the given seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with a positive balance. (optional)
     * @param withSpend Return budgets with a positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getBudgetsBySellerCampaignIdAsync(String sellerCampaignId, String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, String type, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getBudgetsBySellerCampaignIdValidateBeforeCall(sellerCampaignId, authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, type, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSeller
     * @param sellerId Id of the seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerCall(String sellerId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/sellers/{sellerId}"
            .replaceAll("\\{" + "sellerId" + "\\}", apiClient.escapeString(sellerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerValidateBeforeCall(String sellerId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerId' is set
        if (sellerId == null) {
            throw new ApiException("Missing the required parameter 'sellerId' when calling getSeller(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSeller(Async)");
        }
        

        okhttp3.Call call = getSellerCall(sellerId, authorization, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get details for a seller.
     * Returns details for the selected seller.  For example                    {          \&quot;id\&quot; : \&quot;123456\&quot;          \&quot;sellerName\&quot;: \&quot;HBogart\&quot;,      }
     * @param sellerId Id of the seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @return SellerBase
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerBase getSeller(String sellerId, String authorization) throws ApiException {
        ApiResponse<SellerBase> resp = getSellerWithHttpInfo(sellerId, authorization);
        return resp.getData();
    }

    /**
     * Get details for a seller.
     * Returns details for the selected seller.  For example                    {          \&quot;id\&quot; : \&quot;123456\&quot;          \&quot;sellerName\&quot;: \&quot;HBogart\&quot;,      }
     * @param sellerId Id of the seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @return ApiResponse&lt;SellerBase&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerBase> getSellerWithHttpInfo(String sellerId, String authorization) throws ApiException {
        okhttp3.Call call = getSellerValidateBeforeCall(sellerId, authorization, null, null);
        Type localVarReturnType = new TypeToken<SellerBase>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get details for a seller. (asynchronously)
     * Returns details for the selected seller.  For example                    {          \&quot;id\&quot; : \&quot;123456\&quot;          \&quot;sellerName\&quot;: \&quot;HBogart\&quot;,      }
     * @param sellerId Id of the seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerAsync(String sellerId, String authorization, final ApiCallback<SellerBase> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerValidateBeforeCall(sellerId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerBase>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellerBudget
     * @param budgetId  (required)
     * @param authorization JWT Bearer Token (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerBudgetCall(Long budgetId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/budgets/{budgetId}"
            .replaceAll("\\{" + "budgetId" + "\\}", apiClient.escapeString(budgetId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerBudgetValidateBeforeCall(Long budgetId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'budgetId' is set
        if (budgetId == null) {
            throw new ApiException("Missing the required parameter 'budgetId' when calling getSellerBudget(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellerBudget(Async)");
        }
        

        okhttp3.Call call = getSellerBudgetCall(budgetId, authorization, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get details for a budget.
     * Return a budget. For example:                    {          \&quot;id\&quot;: \&quot;1759183\&quot;,          \&quot;sellerId\&quot;: \&quot;321392\&quot;,          \&quot;campaignIds\&quot;: [              143962          ],          \&quot;budgetType\&quot;: \&quot;Capped\&quot;,          \&quot;amount\&quot;: 1000,          \&quot;startDate\&quot;: \&quot;2021-01-11\&quot;,          \&quot;endDate\&quot;: \&quot;2021-01-12\&quot;,          \&quot;spend\&quot;: null,          \&quot;status\&quot;: \&quot;Active\&quot;      }                A budget limits the spend of a seller for one or more campaigns.                There are three types of budget:&lt;br /&gt;&lt;b&gt;Uncapped&lt;/b&gt; budgets put no limit on the total amount of spend.&lt;br /&gt;&lt;b&gt;Capped&lt;/b&gt; budgets limit the total spend to a fixed amount.&lt;br /&gt;&lt;b&gt;Daily&lt;/b&gt; budgets limit daily spend to a fixed amount.&lt;br /&gt;                In addition, budgets can limit the spend to a specific range of dates using  the start and end date attributes. Finally a budget must be active to be used.                &lt;b&gt;Spend&lt;/b&gt; approximates the current spend against this budget. There may be a lag  between when an ad is clicked and the time it accrues to the spend.  Daily budgets  show spend against the most recent day only.
     * @param budgetId  (required)
     * @param authorization JWT Bearer Token (required)
     * @return SellerBudgetMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerBudgetMessage getSellerBudget(Long budgetId, String authorization) throws ApiException {
        ApiResponse<SellerBudgetMessage> resp = getSellerBudgetWithHttpInfo(budgetId, authorization);
        return resp.getData();
    }

    /**
     * Get details for a budget.
     * Return a budget. For example:                    {          \&quot;id\&quot;: \&quot;1759183\&quot;,          \&quot;sellerId\&quot;: \&quot;321392\&quot;,          \&quot;campaignIds\&quot;: [              143962          ],          \&quot;budgetType\&quot;: \&quot;Capped\&quot;,          \&quot;amount\&quot;: 1000,          \&quot;startDate\&quot;: \&quot;2021-01-11\&quot;,          \&quot;endDate\&quot;: \&quot;2021-01-12\&quot;,          \&quot;spend\&quot;: null,          \&quot;status\&quot;: \&quot;Active\&quot;      }                A budget limits the spend of a seller for one or more campaigns.                There are three types of budget:&lt;br /&gt;&lt;b&gt;Uncapped&lt;/b&gt; budgets put no limit on the total amount of spend.&lt;br /&gt;&lt;b&gt;Capped&lt;/b&gt; budgets limit the total spend to a fixed amount.&lt;br /&gt;&lt;b&gt;Daily&lt;/b&gt; budgets limit daily spend to a fixed amount.&lt;br /&gt;                In addition, budgets can limit the spend to a specific range of dates using  the start and end date attributes. Finally a budget must be active to be used.                &lt;b&gt;Spend&lt;/b&gt; approximates the current spend against this budget. There may be a lag  between when an ad is clicked and the time it accrues to the spend.  Daily budgets  show spend against the most recent day only.
     * @param budgetId  (required)
     * @param authorization JWT Bearer Token (required)
     * @return ApiResponse&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerBudgetMessage> getSellerBudgetWithHttpInfo(Long budgetId, String authorization) throws ApiException {
        okhttp3.Call call = getSellerBudgetValidateBeforeCall(budgetId, authorization, null, null);
        Type localVarReturnType = new TypeToken<SellerBudgetMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get details for a budget. (asynchronously)
     * Return a budget. For example:                    {          \&quot;id\&quot;: \&quot;1759183\&quot;,          \&quot;sellerId\&quot;: \&quot;321392\&quot;,          \&quot;campaignIds\&quot;: [              143962          ],          \&quot;budgetType\&quot;: \&quot;Capped\&quot;,          \&quot;amount\&quot;: 1000,          \&quot;startDate\&quot;: \&quot;2021-01-11\&quot;,          \&quot;endDate\&quot;: \&quot;2021-01-12\&quot;,          \&quot;spend\&quot;: null,          \&quot;status\&quot;: \&quot;Active\&quot;      }                A budget limits the spend of a seller for one or more campaigns.                There are three types of budget:&lt;br /&gt;&lt;b&gt;Uncapped&lt;/b&gt; budgets put no limit on the total amount of spend.&lt;br /&gt;&lt;b&gt;Capped&lt;/b&gt; budgets limit the total spend to a fixed amount.&lt;br /&gt;&lt;b&gt;Daily&lt;/b&gt; budgets limit daily spend to a fixed amount.&lt;br /&gt;                In addition, budgets can limit the spend to a specific range of dates using  the start and end date attributes. Finally a budget must be active to be used.                &lt;b&gt;Spend&lt;/b&gt; approximates the current spend against this budget. There may be a lag  between when an ad is clicked and the time it accrues to the spend.  Daily budgets  show spend against the most recent day only.
     * @param budgetId  (required)
     * @param authorization JWT Bearer Token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerBudgetAsync(Long budgetId, String authorization, final ApiCallback<SellerBudgetMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerBudgetValidateBeforeCall(budgetId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerBudgetMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellerBudgets
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param sellerId Return only budgets belonging to the given seller. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerBudgetsCall(String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String sellerId, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/budgets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (status != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("status", status));
        }

        if (withBalance != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withBalance", withBalance));
        }

        if (withSpend != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withSpend", withSpend));
        }

        if (endAfterDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("endAfterDate", endAfterDate));
        }

        if (startBeforeDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("startBeforeDate", startBeforeDate));
        }

        if (campaignId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignId", campaignId));
        }

        if (sellerId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sellerId", sellerId));
        }

        if (type != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("type", type));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerBudgetsValidateBeforeCall(String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String sellerId, String type, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellerBudgets(Async)");
        }
        

        okhttp3.Call call = getSellerBudgetsCall(authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, sellerId, type, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of budgets.
     * Return a collection of budgets filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    &lt;b&gt;Date filter.&lt;/b&gt; Filtering can return only budgets that were active for a  date range by specifying the startBeforeDate and endAfterDate. Leaving off  either value makes the range open ended.  To get budgets that were active  on a specific date, set both values to that day.    &lt;b&gt;Spend.&lt;/b&gt; If the endAfterDate is supplied, the spend excludes spend that  happened after that date. In the case of a daily budget, only the spend for  the final day is displayed.    See the budgets endpoint for additional details.
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param sellerId Return only budgets belonging to the given seller. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> getSellerBudgets(String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String sellerId, String type) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = getSellerBudgetsWithHttpInfo(authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, sellerId, type);
        return resp.getData();
    }

    /**
     * Get a collection of budgets.
     * Return a collection of budgets filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    &lt;b&gt;Date filter.&lt;/b&gt; Filtering can return only budgets that were active for a  date range by specifying the startBeforeDate and endAfterDate. Leaving off  either value makes the range open ended.  To get budgets that were active  on a specific date, set both values to that day.    &lt;b&gt;Spend.&lt;/b&gt; If the endAfterDate is supplied, the spend excludes spend that  happened after that date. In the case of a daily budget, only the spend for  the final day is displayed.    See the budgets endpoint for additional details.
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param sellerId Return only budgets belonging to the given seller. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> getSellerBudgetsWithHttpInfo(String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String sellerId, String type) throws ApiException {
        okhttp3.Call call = getSellerBudgetsValidateBeforeCall(authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, sellerId, type, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of budgets. (asynchronously)
     * Return a collection of budgets filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.    &lt;b&gt;Date filter.&lt;/b&gt; Filtering can return only budgets that were active for a  date range by specifying the startBeforeDate and endAfterDate. Leaving off  either value makes the range open ended.  To get budgets that were active  on a specific date, set both values to that day.    &lt;b&gt;Spend.&lt;/b&gt; If the endAfterDate is supplied, the spend excludes spend that  happened after that date. In the case of a daily budget, only the spend for  the final day is displayed.    See the budgets endpoint for additional details.
     * @param authorization JWT Bearer Token (required)
     * @param status Return only budgets with the given status. (optional)
     * @param withBalance Return only budgets with the given status. (optional)
     * @param withSpend Return budgets with any positive spend. (optional)
     * @param endAfterDate Return budgets that end after the given date. (optional)
     * @param startBeforeDate Return budgets that start on or before the given date. (optional)
     * @param campaignId Return only budgets that pay for a given campaign. (optional)
     * @param sellerId Return only budgets belonging to the given seller. (optional)
     * @param type Return only budgets with the given budget type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerBudgetsAsync(String authorization, String status, Boolean withBalance, Boolean withSpend, OffsetDateTime endAfterDate, OffsetDateTime startBeforeDate, Integer campaignId, String sellerId, String type, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerBudgetsValidateBeforeCall(authorization, status, withBalance, withSpend, endAfterDate, startBeforeDate, campaignId, sellerId, type, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellerCampaign
     * @param sellerCampaignId Id of the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerCampaignCall(String sellerCampaignId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/seller-campaigns/{sellerCampaignId}"
            .replaceAll("\\{" + "sellerCampaignId" + "\\}", apiClient.escapeString(sellerCampaignId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerCampaignValidateBeforeCall(String sellerCampaignId, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerCampaignId' is set
        if (sellerCampaignId == null) {
            throw new ApiException("Missing the required parameter 'sellerCampaignId' when calling getSellerCampaign(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellerCampaign(Async)");
        }
        

        okhttp3.Call call = getSellerCampaignCall(sellerCampaignId, authorization, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get details for a seller campaign.
     * Return details for a seller campaign.  For example,                    {          \&quot;id\&quot;: \&quot;543210.123456\&quot;,          \&quot;suspendedSince\&quot;: \&quot;2018-07-30\&quot;,          \&quot;sellerId\&quot;: \&quot;543210\&quot;,          \&quot;campaignId\&quot;: 123456,          \&quot;bid\&quot;: 1.55      }                An active seller campaign is one for which the value of &lt;b&gt;suspendedSince&lt;/b&gt; is null and  the &lt;b&gt;bid&lt;/b&gt; is positive. The currency of the bid is the &lt;b&gt;bidCurrency&lt;/b&gt; of the  associated campaign.                Any active seller campaign must also have an active total (capped or uncapped) budget.  It may optionally have an active daily budget as well to further limit spending.
     * @param sellerCampaignId Id of the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @return SellerCampaignMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerCampaignMessage getSellerCampaign(String sellerCampaignId, String authorization) throws ApiException {
        ApiResponse<SellerCampaignMessage> resp = getSellerCampaignWithHttpInfo(sellerCampaignId, authorization);
        return resp.getData();
    }

    /**
     * Get details for a seller campaign.
     * Return details for a seller campaign.  For example,                    {          \&quot;id\&quot;: \&quot;543210.123456\&quot;,          \&quot;suspendedSince\&quot;: \&quot;2018-07-30\&quot;,          \&quot;sellerId\&quot;: \&quot;543210\&quot;,          \&quot;campaignId\&quot;: 123456,          \&quot;bid\&quot;: 1.55      }                An active seller campaign is one for which the value of &lt;b&gt;suspendedSince&lt;/b&gt; is null and  the &lt;b&gt;bid&lt;/b&gt; is positive. The currency of the bid is the &lt;b&gt;bidCurrency&lt;/b&gt; of the  associated campaign.                Any active seller campaign must also have an active total (capped or uncapped) budget.  It may optionally have an active daily budget as well to further limit spending.
     * @param sellerCampaignId Id of the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @return ApiResponse&lt;SellerCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerCampaignMessage> getSellerCampaignWithHttpInfo(String sellerCampaignId, String authorization) throws ApiException {
        okhttp3.Call call = getSellerCampaignValidateBeforeCall(sellerCampaignId, authorization, null, null);
        Type localVarReturnType = new TypeToken<SellerCampaignMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get details for a seller campaign. (asynchronously)
     * Return details for a seller campaign.  For example,                    {          \&quot;id\&quot;: \&quot;543210.123456\&quot;,          \&quot;suspendedSince\&quot;: \&quot;2018-07-30\&quot;,          \&quot;sellerId\&quot;: \&quot;543210\&quot;,          \&quot;campaignId\&quot;: 123456,          \&quot;bid\&quot;: 1.55      }                An active seller campaign is one for which the value of &lt;b&gt;suspendedSince&lt;/b&gt; is null and  the &lt;b&gt;bid&lt;/b&gt; is positive. The currency of the bid is the &lt;b&gt;bidCurrency&lt;/b&gt; of the  associated campaign.                Any active seller campaign must also have an active total (capped or uncapped) budget.  It may optionally have an active daily budget as well to further limit spending.
     * @param sellerCampaignId Id of the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerCampaignAsync(String sellerCampaignId, String authorization, final ApiCallback<SellerCampaignMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerCampaignValidateBeforeCall(sellerCampaignId, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerCampaignMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellerCampaigns
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param sellerId Return only seller campaigns belonging to the given seller. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerCampaignsCall(String authorization, String sellerStatus, String sellerId, Integer campaignId, String budgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/seller-campaigns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sellerStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sellerStatus", sellerStatus));
        }

        if (sellerId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sellerId", sellerId));
        }

        if (campaignId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignId", campaignId));
        }

        if (budgetStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("budgetStatus", budgetStatus));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerCampaignsValidateBeforeCall(String authorization, String sellerStatus, String sellerId, Integer campaignId, String budgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellerCampaigns(Async)");
        }
        

        okhttp3.Call call = getSellerCampaignsCall(authorization, sellerStatus, sellerId, campaignId, budgetStatus, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of seller campaigns.
     * Return a collection of seller campaigns filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param sellerId Return only seller campaigns belonging to the given seller. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @return List&lt;SellerCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerCampaignMessage> getSellerCampaigns(String authorization, String sellerStatus, String sellerId, Integer campaignId, String budgetStatus) throws ApiException {
        ApiResponse<List<SellerCampaignMessage>> resp = getSellerCampaignsWithHttpInfo(authorization, sellerStatus, sellerId, campaignId, budgetStatus);
        return resp.getData();
    }

    /**
     * Get a collection of seller campaigns.
     * Return a collection of seller campaigns filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param sellerId Return only seller campaigns belonging to the given seller. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @return ApiResponse&lt;List&lt;SellerCampaignMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerCampaignMessage>> getSellerCampaignsWithHttpInfo(String authorization, String sellerStatus, String sellerId, Integer campaignId, String budgetStatus) throws ApiException {
        okhttp3.Call call = getSellerCampaignsValidateBeforeCall(authorization, sellerStatus, sellerId, campaignId, budgetStatus, null, null);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of seller campaigns. (asynchronously)
     * Return a collection of seller campaigns filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param sellerId Return only seller campaigns belonging to the given seller. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerCampaignsAsync(String authorization, String sellerStatus, String sellerId, Integer campaignId, String budgetStatus, final ApiCallback<List<SellerCampaignMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerCampaignsValidateBeforeCall(authorization, sellerStatus, sellerId, campaignId, budgetStatus, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellerCampaignsBySeller
     * @param sellerId Return only seller campaigns belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellerCampaignsBySellerCall(String sellerId, String authorization, String sellerStatus, Integer campaignId, String budgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/sellers/{sellerId}/seller-campaigns"
            .replaceAll("\\{" + "sellerId" + "\\}", apiClient.escapeString(sellerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sellerStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sellerStatus", sellerStatus));
        }

        if (campaignId != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignId", campaignId));
        }

        if (budgetStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("budgetStatus", budgetStatus));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellerCampaignsBySellerValidateBeforeCall(String sellerId, String authorization, String sellerStatus, Integer campaignId, String budgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerId' is set
        if (sellerId == null) {
            throw new ApiException("Missing the required parameter 'sellerId' when calling getSellerCampaignsBySeller(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellerCampaignsBySeller(Async)");
        }
        

        okhttp3.Call call = getSellerCampaignsBySellerCall(sellerId, authorization, sellerStatus, campaignId, budgetStatus, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of seller campaigns for this seller.
     * Return a collection of seller campaigns for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  See the seller campaigns endpoint for additional details.
     * @param sellerId Return only seller campaigns belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @return List&lt;SellerCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerCampaignMessage> getSellerCampaignsBySeller(String sellerId, String authorization, String sellerStatus, Integer campaignId, String budgetStatus) throws ApiException {
        ApiResponse<List<SellerCampaignMessage>> resp = getSellerCampaignsBySellerWithHttpInfo(sellerId, authorization, sellerStatus, campaignId, budgetStatus);
        return resp.getData();
    }

    /**
     * Get a collection of seller campaigns for this seller.
     * Return a collection of seller campaigns for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  See the seller campaigns endpoint for additional details.
     * @param sellerId Return only seller campaigns belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @return ApiResponse&lt;List&lt;SellerCampaignMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerCampaignMessage>> getSellerCampaignsBySellerWithHttpInfo(String sellerId, String authorization, String sellerStatus, Integer campaignId, String budgetStatus) throws ApiException {
        okhttp3.Call call = getSellerCampaignsBySellerValidateBeforeCall(sellerId, authorization, sellerStatus, campaignId, budgetStatus, null, null);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of seller campaigns for this seller. (asynchronously)
     * Return a collection of seller campaigns for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  See the seller campaigns endpoint for additional details.
     * @param sellerId Return only seller campaigns belonging to the given seller. (required)
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only seller campaigns for sellers with the given status. (optional)
     * @param campaignId Return only seller campaigns associated with the given campaign. (optional)
     * @param budgetStatus Return only seller campaigns whose budget has the given status. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellerCampaignsBySellerAsync(String sellerId, String authorization, String sellerStatus, Integer campaignId, String budgetStatus, final ApiCallback<List<SellerCampaignMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellerCampaignsBySellerValidateBeforeCall(sellerId, authorization, sellerStatus, campaignId, budgetStatus, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSellers
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only sellers with specific status. (optional)
     * @param withProducts Return only sellers with or without products in catalog. (optional)
     * @param withBudgetStatus Return only sellers with specific budget status. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getSellersCall(String authorization, String sellerStatus, Boolean withProducts, String withBudgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/sellers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sellerStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sellerStatus", sellerStatus));
        }

        if (withProducts != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withProducts", withProducts));
        }

        if (withBudgetStatus != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("withBudgetStatus", withBudgetStatus));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSellersValidateBeforeCall(String authorization, String sellerStatus, Boolean withProducts, String withBudgetStatus, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getSellers(Async)");
        }
        

        okhttp3.Call call = getSellersCall(authorization, sellerStatus, withProducts, withBudgetStatus, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get a collection of sellers.
     * Return a collection of sellers filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only sellers with specific status. (optional)
     * @param withProducts Return only sellers with or without products in catalog. (optional)
     * @param withBudgetStatus Return only sellers with specific budget status. (optional)
     * @return List&lt;SellerBase&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBase> getSellers(String authorization, String sellerStatus, Boolean withProducts, String withBudgetStatus) throws ApiException {
        ApiResponse<List<SellerBase>> resp = getSellersWithHttpInfo(authorization, sellerStatus, withProducts, withBudgetStatus);
        return resp.getData();
    }

    /**
     * Get a collection of sellers.
     * Return a collection of sellers filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only sellers with specific status. (optional)
     * @param withProducts Return only sellers with or without products in catalog. (optional)
     * @param withBudgetStatus Return only sellers with specific budget status. (optional)
     * @return ApiResponse&lt;List&lt;SellerBase&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBase>> getSellersWithHttpInfo(String authorization, String sellerStatus, Boolean withProducts, String withBudgetStatus) throws ApiException {
        okhttp3.Call call = getSellersValidateBeforeCall(authorization, sellerStatus, withProducts, withBudgetStatus, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBase>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a collection of sellers. (asynchronously)
     * Return a collection of sellers filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.
     * @param authorization JWT Bearer Token (required)
     * @param sellerStatus Return only sellers with specific status. (optional)
     * @param withProducts Return only sellers with or without products in catalog. (optional)
     * @param withBudgetStatus Return only sellers with specific budget status. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getSellersAsync(String authorization, String sellerStatus, Boolean withProducts, String withBudgetStatus, final ApiCallback<List<SellerBase>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getSellersValidateBeforeCall(authorization, sellerStatus, withProducts, withBudgetStatus, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBase>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateSellerBudget
     * @param budgetId Id of the budget being modified. (required)
     * @param startDate Future start date for this budget. (required)
     * @param suspended Indicates if a budget should be suspended or not. (required)
     * @param amount Limit for this budget (type must not be Uncapped). (required)
     * @param endDate Future end date for this budget. (required)
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Campaigns funded by this budget. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateSellerBudgetCall(Long budgetId, OffsetDateTime startDate, Boolean suspended, String amount, String endDate, String authorization, List<Integer> campaignIds, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = campaignIds;

        // create path and map variables
        String localVarPath = "/v2/crp/budgets/{budgetId}"
            .replaceAll("\\{" + "budgetId" + "\\}", apiClient.escapeString(budgetId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (startDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("startDate", startDate));
        }

        if (suspended != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("suspended", suspended));
        }

        if (amount != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("amount", amount));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("endDate", endDate));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSellerBudgetValidateBeforeCall(Long budgetId, OffsetDateTime startDate, Boolean suspended, String amount, String endDate, String authorization, List<Integer> campaignIds, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'budgetId' is set
        if (budgetId == null) {
            throw new ApiException("Missing the required parameter 'budgetId' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'suspended' is set
        if (suspended == null) {
            throw new ApiException("Missing the required parameter 'suspended' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'amount' is set
        if (amount == null) {
            throw new ApiException("Missing the required parameter 'amount' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateSellerBudget(Async)");
        }
        
        // verify the required parameter 'campaignIds' is set
        if (campaignIds == null) {
            throw new ApiException("Missing the required parameter 'campaignIds' when calling updateSellerBudget(Async)");
        }
        

        okhttp3.Call call = updateSellerBudgetCall(budgetId, startDate, suspended, amount, endDate, authorization, campaignIds, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Modify a single budget.
     * Modify an existing active budget to change its limitations or status.  All three types of budgets can be modified.                See the additional restrictions listed in the PATCH budgets endpoint.
     * @param budgetId Id of the budget being modified. (required)
     * @param startDate Future start date for this budget. (required)
     * @param suspended Indicates if a budget should be suspended or not. (required)
     * @param amount Limit for this budget (type must not be Uncapped). (required)
     * @param endDate Future end date for this budget. (required)
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Campaigns funded by this budget. (required)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> updateSellerBudget(Long budgetId, OffsetDateTime startDate, Boolean suspended, String amount, String endDate, String authorization, List<Integer> campaignIds) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = updateSellerBudgetWithHttpInfo(budgetId, startDate, suspended, amount, endDate, authorization, campaignIds);
        return resp.getData();
    }

    /**
     * Modify a single budget.
     * Modify an existing active budget to change its limitations or status.  All three types of budgets can be modified.                See the additional restrictions listed in the PATCH budgets endpoint.
     * @param budgetId Id of the budget being modified. (required)
     * @param startDate Future start date for this budget. (required)
     * @param suspended Indicates if a budget should be suspended or not. (required)
     * @param amount Limit for this budget (type must not be Uncapped). (required)
     * @param endDate Future end date for this budget. (required)
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Campaigns funded by this budget. (required)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> updateSellerBudgetWithHttpInfo(Long budgetId, OffsetDateTime startDate, Boolean suspended, String amount, String endDate, String authorization, List<Integer> campaignIds) throws ApiException {
        okhttp3.Call call = updateSellerBudgetValidateBeforeCall(budgetId, startDate, suspended, amount, endDate, authorization, campaignIds, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Modify a single budget. (asynchronously)
     * Modify an existing active budget to change its limitations or status.  All three types of budgets can be modified.                See the additional restrictions listed in the PATCH budgets endpoint.
     * @param budgetId Id of the budget being modified. (required)
     * @param startDate Future start date for this budget. (required)
     * @param suspended Indicates if a budget should be suspended or not. (required)
     * @param amount Limit for this budget (type must not be Uncapped). (required)
     * @param endDate Future end date for this budget. (required)
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Campaigns funded by this budget. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateSellerBudgetAsync(Long budgetId, OffsetDateTime startDate, Boolean suspended, String amount, String endDate, String authorization, List<Integer> campaignIds, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateSellerBudgetValidateBeforeCall(budgetId, startDate, suspended, amount, endDate, authorization, campaignIds, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateSellerBudgets
     * @param authorization JWT Bearer Token (required)
     * @param updateSellerBudgets  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateSellerBudgetsCall(String authorization, List<UpdateSellerBudgetMessage> updateSellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = updateSellerBudgets;

        // create path and map variables
        String localVarPath = "/v2/crp/budgets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSellerBudgetsValidateBeforeCall(String authorization, List<UpdateSellerBudgetMessage> updateSellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateSellerBudgets(Async)");
        }
        
        // verify the required parameter 'updateSellerBudgets' is set
        if (updateSellerBudgets == null) {
            throw new ApiException("Missing the required parameter 'updateSellerBudgets' when calling updateSellerBudgets(Async)");
        }
        

        okhttp3.Call call = updateSellerBudgetsCall(authorization, updateSellerBudgets, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Modify a collection of budgets.
     * Modify one or more existing active budgets to change their limitations or status.  All three types of budgets can be modified.                The following constraints apply when modifying an existing budget.                • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty subset of the original campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MAY be supplied for budgets that have not yet started&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be a future date greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.                Adding new campaigns to a budget is not allowed. In addition, reducing the amount for  a Capped budget to a value less than the current spend not allowed.
     * @param authorization JWT Bearer Token (required)
     * @param updateSellerBudgets  (required)
     * @return List&lt;SellerBudgetMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerBudgetMessage> updateSellerBudgets(String authorization, List<UpdateSellerBudgetMessage> updateSellerBudgets) throws ApiException {
        ApiResponse<List<SellerBudgetMessage>> resp = updateSellerBudgetsWithHttpInfo(authorization, updateSellerBudgets);
        return resp.getData();
    }

    /**
     * Modify a collection of budgets.
     * Modify one or more existing active budgets to change their limitations or status.  All three types of budgets can be modified.                The following constraints apply when modifying an existing budget.                • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty subset of the original campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MAY be supplied for budgets that have not yet started&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be a future date greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.                Adding new campaigns to a budget is not allowed. In addition, reducing the amount for  a Capped budget to a value less than the current spend not allowed.
     * @param authorization JWT Bearer Token (required)
     * @param updateSellerBudgets  (required)
     * @return ApiResponse&lt;List&lt;SellerBudgetMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerBudgetMessage>> updateSellerBudgetsWithHttpInfo(String authorization, List<UpdateSellerBudgetMessage> updateSellerBudgets) throws ApiException {
        okhttp3.Call call = updateSellerBudgetsValidateBeforeCall(authorization, updateSellerBudgets, null, null);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Modify a collection of budgets. (asynchronously)
     * Modify one or more existing active budgets to change their limitations or status.  All three types of budgets can be modified.                The following constraints apply when modifying an existing budget.                • &lt;b&gt;campaignIds&lt;/b&gt;: a non-empty subset of the original campaign ids MUST be supplied&lt;br /&gt;  • &lt;b&gt;amount&lt;/b&gt;: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative&lt;br /&gt;  • &lt;b&gt;startDate&lt;/b&gt;: a future start date MAY be supplied for budgets that have not yet started&lt;br /&gt;  • &lt;b&gt;endDate&lt;/b&gt;: an end date MAY be supplied and if supplied MUST be a future date greater than the start date&lt;br /&gt;                Other attributes MUST NOT be supplied.                Adding new campaigns to a budget is not allowed. In addition, reducing the amount for  a Capped budget to a value less than the current spend not allowed.
     * @param authorization JWT Bearer Token (required)
     * @param updateSellerBudgets  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateSellerBudgetsAsync(String authorization, List<UpdateSellerBudgetMessage> updateSellerBudgets, final ApiCallback<List<SellerBudgetMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateSellerBudgetsValidateBeforeCall(authorization, updateSellerBudgets, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerBudgetMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateSellerCampaign
     * @param sellerCampaignId Id of the existing seller campaign to update (required)
     * @param bid The new bid for the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateSellerCampaignCall(String sellerCampaignId, Double bid, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v2/crp/seller-campaigns/{sellerCampaignId}"
            .replaceAll("\\{" + "sellerCampaignId" + "\\}", apiClient.escapeString(sellerCampaignId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (bid != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("bid", bid));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSellerCampaignValidateBeforeCall(String sellerCampaignId, Double bid, String authorization, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'sellerCampaignId' is set
        if (sellerCampaignId == null) {
            throw new ApiException("Missing the required parameter 'sellerCampaignId' when calling updateSellerCampaign(Async)");
        }
        
        // verify the required parameter 'bid' is set
        if (bid == null) {
            throw new ApiException("Missing the required parameter 'bid' when calling updateSellerCampaign(Async)");
        }
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateSellerCampaign(Async)");
        }
        

        okhttp3.Call call = updateSellerCampaignCall(sellerCampaignId, bid, authorization, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update an existing seller campaign.
     * Patching a seller campaign allows the bid to be modified. The bid must be a non-negative value.  Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param sellerCampaignId Id of the existing seller campaign to update (required)
     * @param bid The new bid for the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @return SellerCampaignMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerCampaignMessage updateSellerCampaign(String sellerCampaignId, Double bid, String authorization) throws ApiException {
        ApiResponse<SellerCampaignMessage> resp = updateSellerCampaignWithHttpInfo(sellerCampaignId, bid, authorization);
        return resp.getData();
    }

    /**
     * Update an existing seller campaign.
     * Patching a seller campaign allows the bid to be modified. The bid must be a non-negative value.  Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param sellerCampaignId Id of the existing seller campaign to update (required)
     * @param bid The new bid for the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @return ApiResponse&lt;SellerCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerCampaignMessage> updateSellerCampaignWithHttpInfo(String sellerCampaignId, Double bid, String authorization) throws ApiException {
        okhttp3.Call call = updateSellerCampaignValidateBeforeCall(sellerCampaignId, bid, authorization, null, null);
        Type localVarReturnType = new TypeToken<SellerCampaignMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an existing seller campaign. (asynchronously)
     * Patching a seller campaign allows the bid to be modified. The bid must be a non-negative value.  Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param sellerCampaignId Id of the existing seller campaign to update (required)
     * @param bid The new bid for the seller campaign. (required)
     * @param authorization JWT Bearer Token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateSellerCampaignAsync(String sellerCampaignId, Double bid, String authorization, final ApiCallback<SellerCampaignMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateSellerCampaignValidateBeforeCall(sellerCampaignId, bid, authorization, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerCampaignMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateSellerCampaigns
     * @param authorization JWT Bearer Token (required)
     * @param campaignMessages  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateSellerCampaignsCall(String authorization, List<SellerCampaignUpdate> campaignMessages, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = campaignMessages;

        // create path and map variables
        String localVarPath = "/v2/crp/seller-campaigns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSellerCampaignsValidateBeforeCall(String authorization, List<SellerCampaignUpdate> campaignMessages, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateSellerCampaigns(Async)");
        }
        
        // verify the required parameter 'campaignMessages' is set
        if (campaignMessages == null) {
            throw new ApiException("Missing the required parameter 'campaignMessages' when calling updateSellerCampaigns(Async)");
        }
        

        okhttp3.Call call = updateSellerCampaignsCall(authorization, campaignMessages, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update a collection of seller campaigns.
     * Patching a collection of seller campaigns allows their bids to be modified.  Each bid must be a non-negative value. Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param authorization JWT Bearer Token (required)
     * @param campaignMessages  (required)
     * @return List&lt;SellerCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerCampaignMessage> updateSellerCampaigns(String authorization, List<SellerCampaignUpdate> campaignMessages) throws ApiException {
        ApiResponse<List<SellerCampaignMessage>> resp = updateSellerCampaignsWithHttpInfo(authorization, campaignMessages);
        return resp.getData();
    }

    /**
     * Update a collection of seller campaigns.
     * Patching a collection of seller campaigns allows their bids to be modified.  Each bid must be a non-negative value. Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param authorization JWT Bearer Token (required)
     * @param campaignMessages  (required)
     * @return ApiResponse&lt;List&lt;SellerCampaignMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerCampaignMessage>> updateSellerCampaignsWithHttpInfo(String authorization, List<SellerCampaignUpdate> campaignMessages) throws ApiException {
        okhttp3.Call call = updateSellerCampaignsValidateBeforeCall(authorization, campaignMessages, null, null);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a collection of seller campaigns. (asynchronously)
     * Patching a collection of seller campaigns allows their bids to be modified.  Each bid must be a non-negative value. Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.
     * @param authorization JWT Bearer Token (required)
     * @param campaignMessages  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateSellerCampaignsAsync(String authorization, List<SellerCampaignUpdate> campaignMessages, final ApiCallback<List<SellerCampaignMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateSellerCampaignsValidateBeforeCall(authorization, campaignMessages, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerCampaignMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
