/*
 * Marketing API v.1.0
 * IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.
 *
 * OpenAPI spec version: v.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.criteo.marketing.api;

import com.criteo.marketing.ApiCallback;
import com.criteo.marketing.ApiClient;
import com.criteo.marketing.ApiException;
import com.criteo.marketing.ApiResponse;
import com.criteo.marketing.Configuration;
import com.criteo.marketing.Pair;
import com.criteo.marketing.ProgressRequestBody;
import com.criteo.marketing.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.criteo.marketing.model.MarketplaceCampaignMessage;
import com.criteo.marketing.model.SellerBidsMessage;
import com.criteo.marketing.model.SellerBudgetsCreateMessage;
import com.criteo.marketing.model.SellerBudgetsMessage;
import com.criteo.marketing.model.SellerBudgetsUpdateMessage;
import com.criteo.marketing.model.SellerMessage;
import com.criteo.marketing.model.StatsQueryMessage;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SellersApi {
    private ApiClient apiClient;

    public SellersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SellersApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createBudgets
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call createBudgetsCall(String authorization, SellerBudgetsCreateMessage sellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = sellerBudgets;

        // create path and map variables
        String localVarPath = "/v1/sellers/budgets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createBudgetsValidateBeforeCall(String authorization, SellerBudgetsCreateMessage sellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling createBudgets(Async)");
        }
        
        // verify the required parameter 'sellerBudgets' is set
        if (sellerBudgets == null) {
            throw new ApiException("Missing the required parameter 'sellerBudgets' when calling createBudgets(Async)");
        }
        

        okhttp3.Call call = createBudgetsCall(authorization, sellerBudgets, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Creates a budget for a seller/list of sellers.
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.&lt;br /&gt;&lt;b&gt;Amount&lt;/b&gt;: in your currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;h4&gt;Response&lt;/h4&gt;&lt;p&gt;              The budget&#39;s start date will be set to:&lt;br /&gt;              • today: in case no budget is currently set for this seller&lt;br /&gt;              • tomorrow: in case your seller already has a budget running, ending at midnight. Note that start dates are UTC+00:00 based.&lt;br /&gt;              The budget will remain active until being completely consumed or stopped.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              When a seller&#39;s budget is totally consumed, display delivery will automatically stop for this specific seller.&lt;br /&gt;              If budget needs to be updated, by: adding fund, reducing a budget amount or stopping it, refer to the “update budget” endpoint.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @return SellerBudgetsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerBudgetsMessage createBudgets(String authorization, SellerBudgetsCreateMessage sellerBudgets) throws ApiException {
        ApiResponse<SellerBudgetsMessage> resp = createBudgetsWithHttpInfo(authorization, sellerBudgets);
        return resp.getData();
    }

    /**
     * Creates a budget for a seller/list of sellers.
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.&lt;br /&gt;&lt;b&gt;Amount&lt;/b&gt;: in your currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;h4&gt;Response&lt;/h4&gt;&lt;p&gt;              The budget&#39;s start date will be set to:&lt;br /&gt;              • today: in case no budget is currently set for this seller&lt;br /&gt;              • tomorrow: in case your seller already has a budget running, ending at midnight. Note that start dates are UTC+00:00 based.&lt;br /&gt;              The budget will remain active until being completely consumed or stopped.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              When a seller&#39;s budget is totally consumed, display delivery will automatically stop for this specific seller.&lt;br /&gt;              If budget needs to be updated, by: adding fund, reducing a budget amount or stopping it, refer to the “update budget” endpoint.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @return ApiResponse&lt;SellerBudgetsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerBudgetsMessage> createBudgetsWithHttpInfo(String authorization, SellerBudgetsCreateMessage sellerBudgets) throws ApiException {
        okhttp3.Call call = createBudgetsValidateBeforeCall(authorization, sellerBudgets, null, null);
        Type localVarReturnType = new TypeToken<SellerBudgetsMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Creates a budget for a seller/list of sellers. (asynchronously)
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.&lt;br /&gt;&lt;b&gt;Amount&lt;/b&gt;: in your currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;h4&gt;Response&lt;/h4&gt;&lt;p&gt;              The budget&#39;s start date will be set to:&lt;br /&gt;              • today: in case no budget is currently set for this seller&lt;br /&gt;              • tomorrow: in case your seller already has a budget running, ending at midnight. Note that start dates are UTC+00:00 based.&lt;br /&gt;              The budget will remain active until being completely consumed or stopped.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              When a seller&#39;s budget is totally consumed, display delivery will automatically stop for this specific seller.&lt;br /&gt;              If budget needs to be updated, by: adding fund, reducing a budget amount or stopping it, refer to the “update budget” endpoint.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call createBudgetsAsync(String authorization, SellerBudgetsCreateMessage sellerBudgets, final ApiCallback<SellerBudgetsMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = createBudgetsValidateBeforeCall(authorization, sellerBudgets, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerBudgetsMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for get
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param onlyActiveSellers Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false. (optional)
     * @param onlySellersWithProductsInCatalog Optional. Only return sellers that have currently products in the catalog. Default value is false. (optional)
     * @param onlyActiveBudgets Optional. Will return only active budget for each seller. Default value is false (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getCall(String authorization, String campaignIds, Boolean onlyActiveSellers, Boolean onlySellersWithProductsInCatalog, Boolean onlyActiveBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v1/sellers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (campaignIds != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignIds", campaignIds));
        }

        if (onlyActiveSellers != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("onlyActiveSellers", onlyActiveSellers));
        }

        if (onlySellersWithProductsInCatalog != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("onlySellersWithProductsInCatalog", onlySellersWithProductsInCatalog));
        }

        if (onlyActiveBudgets != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("onlyActiveBudgets", onlyActiveBudgets));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getValidateBeforeCall(String authorization, String campaignIds, Boolean onlyActiveSellers, Boolean onlySellersWithProductsInCatalog, Boolean onlyActiveBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling get(Async)");
        }
        

        okhttp3.Call call = getCall(authorization, campaignIds, onlyActiveSellers, onlySellersWithProductsInCatalog, onlyActiveBudgets, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Gets sellers details.
     * Returns a list of sellers with all their details.&lt;br /&gt;  By default, this list will contain all active sellers that have been on-boarded onto the Criteo Reseller Program.&lt;br /&gt;  Note that (in the situation where you would have multiple Criteo Reseller Program campaigns running at the same time) campaign filter can be applied to restrict the response to one or multiple campaign ids.&lt;br /&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;  Only currently running and future seller budgets will be retrieved. Past sellers&#39; budgets can be retrieved from the statistics endpoint.&lt;br /&gt;  Seller&#39;s status has 2 possible values - Active or Inactive - which corresponds to:&lt;br /&gt;  • &lt;b&gt;Active&lt;/b&gt;: Seller in a running campaign, with a bid (CPC) and a budget &amp;gt; 0&lt;br /&gt;  • &lt;b&gt;Inactive&lt;/b&gt;: Seller with a budget consumed or that you explicitly stopped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param onlyActiveSellers Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false. (optional)
     * @param onlySellersWithProductsInCatalog Optional. Only return sellers that have currently products in the catalog. Default value is false. (optional)
     * @param onlyActiveBudgets Optional. Will return only active budget for each seller. Default value is false (optional)
     * @return List&lt;SellerMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<SellerMessage> get(String authorization, String campaignIds, Boolean onlyActiveSellers, Boolean onlySellersWithProductsInCatalog, Boolean onlyActiveBudgets) throws ApiException {
        ApiResponse<List<SellerMessage>> resp = getWithHttpInfo(authorization, campaignIds, onlyActiveSellers, onlySellersWithProductsInCatalog, onlyActiveBudgets);
        return resp.getData();
    }

    /**
     * Gets sellers details.
     * Returns a list of sellers with all their details.&lt;br /&gt;  By default, this list will contain all active sellers that have been on-boarded onto the Criteo Reseller Program.&lt;br /&gt;  Note that (in the situation where you would have multiple Criteo Reseller Program campaigns running at the same time) campaign filter can be applied to restrict the response to one or multiple campaign ids.&lt;br /&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;  Only currently running and future seller budgets will be retrieved. Past sellers&#39; budgets can be retrieved from the statistics endpoint.&lt;br /&gt;  Seller&#39;s status has 2 possible values - Active or Inactive - which corresponds to:&lt;br /&gt;  • &lt;b&gt;Active&lt;/b&gt;: Seller in a running campaign, with a bid (CPC) and a budget &amp;gt; 0&lt;br /&gt;  • &lt;b&gt;Inactive&lt;/b&gt;: Seller with a budget consumed or that you explicitly stopped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param onlyActiveSellers Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false. (optional)
     * @param onlySellersWithProductsInCatalog Optional. Only return sellers that have currently products in the catalog. Default value is false. (optional)
     * @param onlyActiveBudgets Optional. Will return only active budget for each seller. Default value is false (optional)
     * @return ApiResponse&lt;List&lt;SellerMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<SellerMessage>> getWithHttpInfo(String authorization, String campaignIds, Boolean onlyActiveSellers, Boolean onlySellersWithProductsInCatalog, Boolean onlyActiveBudgets) throws ApiException {
        okhttp3.Call call = getValidateBeforeCall(authorization, campaignIds, onlyActiveSellers, onlySellersWithProductsInCatalog, onlyActiveBudgets, null, null);
        Type localVarReturnType = new TypeToken<List<SellerMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets sellers details. (asynchronously)
     * Returns a list of sellers with all their details.&lt;br /&gt;  By default, this list will contain all active sellers that have been on-boarded onto the Criteo Reseller Program.&lt;br /&gt;  Note that (in the situation where you would have multiple Criteo Reseller Program campaigns running at the same time) campaign filter can be applied to restrict the response to one or multiple campaign ids.&lt;br /&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;  Only currently running and future seller budgets will be retrieved. Past sellers&#39; budgets can be retrieved from the statistics endpoint.&lt;br /&gt;  Seller&#39;s status has 2 possible values - Active or Inactive - which corresponds to:&lt;br /&gt;  • &lt;b&gt;Active&lt;/b&gt;: Seller in a running campaign, with a bid (CPC) and a budget &amp;gt; 0&lt;br /&gt;  • &lt;b&gt;Inactive&lt;/b&gt;: Seller with a budget consumed or that you explicitly stopped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param onlyActiveSellers Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false. (optional)
     * @param onlySellersWithProductsInCatalog Optional. Only return sellers that have currently products in the catalog. Default value is false. (optional)
     * @param onlyActiveBudgets Optional. Will return only active budget for each seller. Default value is false (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getAsync(String authorization, String campaignIds, Boolean onlyActiveSellers, Boolean onlySellersWithProductsInCatalog, Boolean onlyActiveBudgets, final ApiCallback<List<SellerMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getValidateBeforeCall(authorization, campaignIds, onlyActiveSellers, onlySellersWithProductsInCatalog, onlyActiveBudgets, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<SellerMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getCampaigns
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param advertiserIds Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user&#39;s portfolio, the call will fail. (optional)
     * @param status Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getCampaignsCall(String authorization, String campaignIds, String advertiserIds, String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/v1/sellers/campaigns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (campaignIds != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("campaignIds", campaignIds));
        }

        if (advertiserIds != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("advertiserIds", advertiserIds));
        }

        if (status != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("status", status));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCampaignsValidateBeforeCall(String authorization, String campaignIds, String advertiserIds, String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getCampaigns(Async)");
        }
        

        okhttp3.Call call = getCampaignsCall(authorization, campaignIds, advertiserIds, status, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Gets campaigns
     * Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user&#39;s portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user&#39;s portfolio will be used.
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param advertiserIds Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user&#39;s portfolio, the call will fail. (optional)
     * @param status Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status. (optional)
     * @return List&lt;MarketplaceCampaignMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<MarketplaceCampaignMessage> getCampaigns(String authorization, String campaignIds, String advertiserIds, String status) throws ApiException {
        ApiResponse<List<MarketplaceCampaignMessage>> resp = getCampaignsWithHttpInfo(authorization, campaignIds, advertiserIds, status);
        return resp.getData();
    }

    /**
     * Gets campaigns
     * Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user&#39;s portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user&#39;s portfolio will be used.
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param advertiserIds Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user&#39;s portfolio, the call will fail. (optional)
     * @param status Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status. (optional)
     * @return ApiResponse&lt;List&lt;MarketplaceCampaignMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<List<MarketplaceCampaignMessage>> getCampaignsWithHttpInfo(String authorization, String campaignIds, String advertiserIds, String status) throws ApiException {
        okhttp3.Call call = getCampaignsValidateBeforeCall(authorization, campaignIds, advertiserIds, status, null, null);
        Type localVarReturnType = new TypeToken<List<MarketplaceCampaignMessage>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets campaigns (asynchronously)
     * Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user&#39;s portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user&#39;s portfolio will be used.
     * @param authorization JWT Bearer Token (required)
     * @param campaignIds Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user&#39;s portfolio, the call will fail. (optional)
     * @param advertiserIds Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user&#39;s portfolio, the call will fail. (optional)
     * @param status Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getCampaignsAsync(String authorization, String campaignIds, String advertiserIds, String status, final ApiCallback<List<MarketplaceCampaignMessage>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getCampaignsValidateBeforeCall(authorization, campaignIds, advertiserIds, status, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<MarketplaceCampaignMessage>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getStats
     * @param authorization JWT Bearer Token (required)
     * @param statsQuery The report query details (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call getStatsCall(String authorization, StatsQueryMessage statsQuery, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = statsQuery;

        // create path and map variables
        String localVarPath = "/v1/sellers/stats";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getStatsValidateBeforeCall(String authorization, StatsQueryMessage statsQuery, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getStats(Async)");
        }
        
        // verify the required parameter 'statsQuery' is set
        if (statsQuery == null) {
            throw new ApiException("Missing the required parameter 'statsQuery' when calling getStats(Async)");
        }
        

        okhttp3.Call call = getStatsCall(authorization, statsQuery, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Generates a statistics report
     * &lt;b&gt;AdvertiserIds&lt;/b&gt;: Optional. The list of advertiser ids, comma-separated. Advertisers not in your portfolio will be skipped. If not present, all the advertisers in the portfolio will be used.&lt;br /&gt;&lt;b&gt;StartDate, EndDate&lt;/b&gt;: Start date (beginning of day) and end date (end of day) to be used for the report generation. Format to use: yyyy-MM-dd (e.g. 2017-10-30).&lt;br /&gt;&lt;b&gt;Dimensions&lt;/b&gt;: The dimensions to be used in the report. Between one and three. Possible values: CampaignId, AdvertiserId, Seller, Day, Week, Month, Year.&lt;br /&gt;&lt;b&gt;Metrics&lt;/b&gt;: The metrics to be used in the report. Possible values: Clicks, AdvertiserCost, Displays.&lt;br /&gt;&lt;b&gt;Format&lt;/b&gt;: The file format of the generated report. Possible values: Csv, Excel, Xml, Json.&lt;br /&gt;&lt;b&gt;Currency&lt;/b&gt;: Optional. The currency to be used in the report. Three-letter capitals. For a list of possible values, please see the full documentation. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;b&gt;Timezone&lt;/b&gt;: Optional. Timezone to be used in the report. Possible values: GMT, PST, JST. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;              StartDate and EndDate are mandatory.&lt;br /&gt;              StartDate should come before, or be equal to EndDate.&lt;br /&gt;              The requested dimensions must be in a supported combination.&lt;br /&gt;              At least one metric must be provided.&lt;br /&gt;              All metrics must be supported.&lt;br /&gt;              The selected advertisers must have at least one campaign.&lt;br /&gt;              Seller dimension is mandatory.&lt;br /&gt;
     * @param authorization JWT Bearer Token (required)
     * @param statsQuery The report query details (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void getStats(String authorization, StatsQueryMessage statsQuery) throws ApiException {
        getStatsWithHttpInfo(authorization, statsQuery);
    }

    /**
     * Generates a statistics report
     * &lt;b&gt;AdvertiserIds&lt;/b&gt;: Optional. The list of advertiser ids, comma-separated. Advertisers not in your portfolio will be skipped. If not present, all the advertisers in the portfolio will be used.&lt;br /&gt;&lt;b&gt;StartDate, EndDate&lt;/b&gt;: Start date (beginning of day) and end date (end of day) to be used for the report generation. Format to use: yyyy-MM-dd (e.g. 2017-10-30).&lt;br /&gt;&lt;b&gt;Dimensions&lt;/b&gt;: The dimensions to be used in the report. Between one and three. Possible values: CampaignId, AdvertiserId, Seller, Day, Week, Month, Year.&lt;br /&gt;&lt;b&gt;Metrics&lt;/b&gt;: The metrics to be used in the report. Possible values: Clicks, AdvertiserCost, Displays.&lt;br /&gt;&lt;b&gt;Format&lt;/b&gt;: The file format of the generated report. Possible values: Csv, Excel, Xml, Json.&lt;br /&gt;&lt;b&gt;Currency&lt;/b&gt;: Optional. The currency to be used in the report. Three-letter capitals. For a list of possible values, please see the full documentation. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;b&gt;Timezone&lt;/b&gt;: Optional. Timezone to be used in the report. Possible values: GMT, PST, JST. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;              StartDate and EndDate are mandatory.&lt;br /&gt;              StartDate should come before, or be equal to EndDate.&lt;br /&gt;              The requested dimensions must be in a supported combination.&lt;br /&gt;              At least one metric must be provided.&lt;br /&gt;              All metrics must be supported.&lt;br /&gt;              The selected advertisers must have at least one campaign.&lt;br /&gt;              Seller dimension is mandatory.&lt;br /&gt;
     * @param authorization JWT Bearer Token (required)
     * @param statsQuery The report query details (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> getStatsWithHttpInfo(String authorization, StatsQueryMessage statsQuery) throws ApiException {
        okhttp3.Call call = getStatsValidateBeforeCall(authorization, statsQuery, null, null);
        return apiClient.execute(call);
    }

    /**
     * Generates a statistics report (asynchronously)
     * &lt;b&gt;AdvertiserIds&lt;/b&gt;: Optional. The list of advertiser ids, comma-separated. Advertisers not in your portfolio will be skipped. If not present, all the advertisers in the portfolio will be used.&lt;br /&gt;&lt;b&gt;StartDate, EndDate&lt;/b&gt;: Start date (beginning of day) and end date (end of day) to be used for the report generation. Format to use: yyyy-MM-dd (e.g. 2017-10-30).&lt;br /&gt;&lt;b&gt;Dimensions&lt;/b&gt;: The dimensions to be used in the report. Between one and three. Possible values: CampaignId, AdvertiserId, Seller, Day, Week, Month, Year.&lt;br /&gt;&lt;b&gt;Metrics&lt;/b&gt;: The metrics to be used in the report. Possible values: Clicks, AdvertiserCost, Displays.&lt;br /&gt;&lt;b&gt;Format&lt;/b&gt;: The file format of the generated report. Possible values: Csv, Excel, Xml, Json.&lt;br /&gt;&lt;b&gt;Currency&lt;/b&gt;: Optional. The currency to be used in the report. Three-letter capitals. For a list of possible values, please see the full documentation. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;b&gt;Timezone&lt;/b&gt;: Optional. Timezone to be used in the report. Possible values: GMT, PST, JST. If not set, the user&#39;s preference setting will be used.&lt;br /&gt;&lt;h4&gt;Validation rules&lt;/h4&gt;              StartDate and EndDate are mandatory.&lt;br /&gt;              StartDate should come before, or be equal to EndDate.&lt;br /&gt;              The requested dimensions must be in a supported combination.&lt;br /&gt;              At least one metric must be provided.&lt;br /&gt;              All metrics must be supported.&lt;br /&gt;              The selected advertisers must have at least one campaign.&lt;br /&gt;              Seller dimension is mandatory.&lt;br /&gt;
     * @param authorization JWT Bearer Token (required)
     * @param statsQuery The report query details (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call getStatsAsync(String authorization, StatsQueryMessage statsQuery, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getStatsValidateBeforeCall(authorization, statsQuery, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for updateBids
     * @param authorization JWT Bearer Token (required)
     * @param sellerBids  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateBidsCall(String authorization, SellerBidsMessage sellerBids, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = sellerBids;

        // create path and map variables
        String localVarPath = "/v1/sellers/bids";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateBidsValidateBeforeCall(String authorization, SellerBidsMessage sellerBids, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateBids(Async)");
        }
        
        // verify the required parameter 'sellerBids' is set
        if (sellerBids == null) {
            throw new ApiException("Missing the required parameter 'sellerBids' when calling updateBids(Async)");
        }
        

        okhttp3.Call call = updateBidsCall(authorization, sellerBids, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Set or update a bid for a seller/list of sellers.
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.              &lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              In case one of the bid values cannot be updated, the whole batch will be dropped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBids  (required)
     * @return SellerBidsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerBidsMessage updateBids(String authorization, SellerBidsMessage sellerBids) throws ApiException {
        ApiResponse<SellerBidsMessage> resp = updateBidsWithHttpInfo(authorization, sellerBids);
        return resp.getData();
    }

    /**
     * Set or update a bid for a seller/list of sellers.
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.              &lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              In case one of the bid values cannot be updated, the whole batch will be dropped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBids  (required)
     * @return ApiResponse&lt;SellerBidsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerBidsMessage> updateBidsWithHttpInfo(String authorization, SellerBidsMessage sellerBids) throws ApiException {
        okhttp3.Call call = updateBidsValidateBeforeCall(authorization, sellerBids, null, null);
        Type localVarReturnType = new TypeToken<SellerBidsMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Set or update a bid for a seller/list of sellers. (asynchronously)
     * &lt;b&gt;Seller name&lt;/b&gt;: can be retrieved from the /sellers/ endpoint. This value is case insensitive.              &lt;h4&gt;Functional cases&lt;/h4&gt;&lt;p&gt;              In case one of the bid values cannot be updated, the whole batch will be dropped.&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBids  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateBidsAsync(String authorization, SellerBidsMessage sellerBids, final ApiCallback<SellerBidsMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateBidsValidateBeforeCall(authorization, sellerBids, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerBidsMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateBudgets
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public okhttp3.Call updateBudgetsCall(String authorization, SellerBudgetsUpdateMessage sellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = sellerBudgets;

        // create path and map variables
        String localVarPath = "/v1/sellers/budgets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (authorization != null) {
            localVarHeaderParams.put("Authorization", apiClient.parameterToString(authorization));
        }

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json", "text/json", "application/xml", "text/xml", "text/html"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded", "text/html"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.setHttpClient(apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            }).build());
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateBudgetsValidateBeforeCall(String authorization, SellerBudgetsUpdateMessage sellerBudgets, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling updateBudgets(Async)");
        }
        
        // verify the required parameter 'sellerBudgets' is set
        if (sellerBudgets == null) {
            throw new ApiException("Missing the required parameter 'sellerBudgets' when calling updateBudgets(Async)");
        }
        

        okhttp3.Call call = updateBudgetsCall(authorization, sellerBudgets, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Updates a budget for a seller/list of sellers.
     * &lt;b&gt;Amount&lt;/b&gt;: Optional. Uses the advertiser&#39;s currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;b&gt;Status&lt;/b&gt;: Optional. Budget&#39;s status, possible values are: [\&quot;Inactive\&quot;,\&quot;Active\&quot;]. If set to null or undefined, status does not change.              &lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;              Budget&#39;s &lt;b&gt;amount&lt;/b&gt; can be decreased if it did not start yet.&lt;br /&gt;              Budget&#39;s &lt;b&gt;status&lt;/b&gt; can only be changed from \&quot;Active\&quot; to \&quot;Inactive\&quot;, if budget already started.&lt;br /&gt;&lt;b&gt;Inactive&lt;/b&gt; budgets cannot be updated.              &lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;h5&gt;Increase budget amount&lt;/h5&gt;&lt;p&gt;              Budget can only be increased if its end date is not reached.&lt;br /&gt;              Amount value must include the amount that has been already spent.&lt;br /&gt;              Example: if you want to add 50€ to a 100€ budget, you should update the amount to 150€, regardless of the amount already spent.&lt;br /&gt;              Or, alternatively, you can set it to \&quot;null\&quot; or leave empty to change the budget to uncapped.&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Stop budget consumption&lt;/h5&gt;&lt;p&gt;              Setting a currently running budget’s status to Inactive, result in:&lt;br /&gt;              • Setting its end date to today (at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Stopping its consumption instantly&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Decrease budget amount&lt;/h5&gt;&lt;p&gt;              In order to decrease the amount of a currently running budget, you have to:&lt;br /&gt;              • Stop budget consumption (making the currently running budget to end at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Create a new budget with a dedicated amount. (that will start the following day, according to UTC+00:00)&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @return SellerBudgetsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SellerBudgetsMessage updateBudgets(String authorization, SellerBudgetsUpdateMessage sellerBudgets) throws ApiException {
        ApiResponse<SellerBudgetsMessage> resp = updateBudgetsWithHttpInfo(authorization, sellerBudgets);
        return resp.getData();
    }

    /**
     * Updates a budget for a seller/list of sellers.
     * &lt;b&gt;Amount&lt;/b&gt;: Optional. Uses the advertiser&#39;s currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;b&gt;Status&lt;/b&gt;: Optional. Budget&#39;s status, possible values are: [\&quot;Inactive\&quot;,\&quot;Active\&quot;]. If set to null or undefined, status does not change.              &lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;              Budget&#39;s &lt;b&gt;amount&lt;/b&gt; can be decreased if it did not start yet.&lt;br /&gt;              Budget&#39;s &lt;b&gt;status&lt;/b&gt; can only be changed from \&quot;Active\&quot; to \&quot;Inactive\&quot;, if budget already started.&lt;br /&gt;&lt;b&gt;Inactive&lt;/b&gt; budgets cannot be updated.              &lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;h5&gt;Increase budget amount&lt;/h5&gt;&lt;p&gt;              Budget can only be increased if its end date is not reached.&lt;br /&gt;              Amount value must include the amount that has been already spent.&lt;br /&gt;              Example: if you want to add 50€ to a 100€ budget, you should update the amount to 150€, regardless of the amount already spent.&lt;br /&gt;              Or, alternatively, you can set it to \&quot;null\&quot; or leave empty to change the budget to uncapped.&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Stop budget consumption&lt;/h5&gt;&lt;p&gt;              Setting a currently running budget’s status to Inactive, result in:&lt;br /&gt;              • Setting its end date to today (at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Stopping its consumption instantly&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Decrease budget amount&lt;/h5&gt;&lt;p&gt;              In order to decrease the amount of a currently running budget, you have to:&lt;br /&gt;              • Stop budget consumption (making the currently running budget to end at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Create a new budget with a dedicated amount. (that will start the following day, according to UTC+00:00)&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @return ApiResponse&lt;SellerBudgetsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SellerBudgetsMessage> updateBudgetsWithHttpInfo(String authorization, SellerBudgetsUpdateMessage sellerBudgets) throws ApiException {
        okhttp3.Call call = updateBudgetsValidateBeforeCall(authorization, sellerBudgets, null, null);
        Type localVarReturnType = new TypeToken<SellerBudgetsMessage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Updates a budget for a seller/list of sellers. (asynchronously)
     * &lt;b&gt;Amount&lt;/b&gt;: Optional. Uses the advertiser&#39;s currency. Set it to \&quot;null\&quot; or leave empty to create an uncapped budget (with no limit).&lt;br /&gt;&lt;b&gt;Status&lt;/b&gt;: Optional. Budget&#39;s status, possible values are: [\&quot;Inactive\&quot;,\&quot;Active\&quot;]. If set to null or undefined, status does not change.              &lt;h4&gt;Validation rules&lt;/h4&gt;&lt;p&gt;              Budgets cannot &lt;b&gt;overlap&lt;/b&gt; with each other for a specific seller.&lt;br /&gt;              Budget&#39;s &lt;b&gt;amount&lt;/b&gt; can be decreased if it did not start yet.&lt;br /&gt;              Budget&#39;s &lt;b&gt;status&lt;/b&gt; can only be changed from \&quot;Active\&quot; to \&quot;Inactive\&quot;, if budget already started.&lt;br /&gt;&lt;b&gt;Inactive&lt;/b&gt; budgets cannot be updated.              &lt;/p&gt;&lt;h4&gt;Functional cases&lt;/h4&gt;&lt;h5&gt;Increase budget amount&lt;/h5&gt;&lt;p&gt;              Budget can only be increased if its end date is not reached.&lt;br /&gt;              Amount value must include the amount that has been already spent.&lt;br /&gt;              Example: if you want to add 50€ to a 100€ budget, you should update the amount to 150€, regardless of the amount already spent.&lt;br /&gt;              Or, alternatively, you can set it to \&quot;null\&quot; or leave empty to change the budget to uncapped.&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Stop budget consumption&lt;/h5&gt;&lt;p&gt;              Setting a currently running budget’s status to Inactive, result in:&lt;br /&gt;              • Setting its end date to today (at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Stopping its consumption instantly&lt;br /&gt;&lt;/p&gt;&lt;h5&gt;Decrease budget amount&lt;/h5&gt;&lt;p&gt;              In order to decrease the amount of a currently running budget, you have to:&lt;br /&gt;              • Stop budget consumption (making the currently running budget to end at 23:59:59, according to UTC+00:00)&lt;br /&gt;              • Create a new budget with a dedicated amount. (that will start the following day, according to UTC+00:00)&lt;br /&gt;&lt;/p&gt;
     * @param authorization JWT Bearer Token (required)
     * @param sellerBudgets  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public okhttp3.Call updateBudgetsAsync(String authorization, SellerBudgetsUpdateMessage sellerBudgets, final ApiCallback<SellerBudgetsMessage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateBudgetsValidateBeforeCall(authorization, sellerBudgets, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SellerBudgetsMessage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
